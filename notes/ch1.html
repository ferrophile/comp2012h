<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<h1 id="constructors">Constructors</h1>
<p>A constructor is a member function of a class called whenever an object of that class is created.</p>
<blockquote>
<p>A constructor has the same name as the class.<br />
A constructor must have no return type, not even <em>void</em>.</p>
</blockquote>
<h3 id="default-constructors">Default constructors</h3>
<p><strong>Default constructors</strong> are called when there is no arguments passed. It is commonly used to initialize data members with default values.</p>
<pre><code>class Word {
public:
    Word() {frequency = 0; str = 0}
private:
    int frequency;
    char * str;
};

int main(int argc, char ** argv) {
    Word movie;
}</code></pre>
<p>A default constructor <em>X::X()</em> will be generated if <strong>no constructor</strong> is provided. It creates a record with empty spaces, but its values cannot be trusted. &gt;Notice this will not happen when there are other constructors provided, and any object initialization without arguments will result in compilation error.</p>
<h3 id="type-conversion-constructor">Type conversion constructor</h3>
<p><strong>Type conversion constructors</strong> accepts one single argument that converts from that type to an equivalent object of that class. The example below uses a type conversion constructor to convert from <em>char*</em> to <em>Word</em>.</p>
<pre><code>class Word {
public:
    Word(cosnt char * s) {
        frequency = 1;
        str = new char [strlen(s) + 1];
        strcpy(str, s);
    }
};

int main(int argc, char ** argv) {
    Word *p = new Word(&quot;action&quot;);
    Word movie(&quot;Titanic&quot;);
    Word director = &quot;James Cameron&quot;;
}</code></pre>
<blockquote>
<p>Notice that constructors with multiple arguments but only one without default values can also count as type conversion constructors.</p>
</blockquote>
<h3 id="copy-constructor">Copy constructor</h3>
<p><strong>Copy constructors</strong> are constructors with <em>only one argument</em> of the same class, so its syntax is <em>X::X(const X&amp;)</em>. They are used to duplicate the argument object.</p>
<p>In the below example, the copy constructor is called when the assignment operator is invoked.</p>
<pre><code>class Word {
public:
    Word(const Word&amp; w) {
        frequency = w.frequency;
        str = new char [strlen(w.str)+1];
        strcpy(str, w.str);
    }
};

int main(int argc, char ** argv) {
    Word movie(&quot;Titanic&quot;); //Type conversion ctor
    Word song(movie); //Copy ctor
}</code></pre>
<p>They are also automatically called when an object of that class is passed (by-value) to a function, or when an object is returned by a function.</p>
<p><strong>Default copy constructors</strong> are automatically generated if no user-defined copy constructors are provided. Member-wise copy is carried out. Hence, the below snippet</p>
<pre><code>Word song = movie;</code></pre>
<p>is equivalent to the following code:</p>
<pre><code>song.frequency = movie.frequency;
song.str = movie.str;</code></pre>
<p>As <em>str</em> is a pointer, both data members now point to the same location. This is known as <strong>shallow copy</strong> and is undesirable in many cases. To fix this problem, <strong>deep copy</strong> should be carried out using a user-defined copy constructor, as illustrated in the first example.</p>
<h3 id="function-overloading">Function Overloading</h3>
<p><strong>Overloading</strong> refers to the use of same name for functions that does different things depending on <em>data types of arguments supplied</em>. Constructors and operators are often overloaded.</p>
<pre><code>class Word {
public:
    Word();
    Word(const char * s, int k = 1);
    Word(const Word&amp; w);
}</code></pre>
<h3 id="default-arguments">Default arguments</h3>
<p>Specifying default arguments is preferred when the functions shows default behavior for most of the time.</p>
<blockquote>
<p>All default arguments must be specified before other arguments.<br />
Default arguments can only be specified <em>once</em> or else compile error will occur. This is usually done in the header file.</p>
</blockquote>
<h3 id="member-initialization-list">Member initialization list</h3>
<p><strong>Member initialization list</strong> provides an alternative way to initialize data members other than within the body of a constructor. In this case, the use of user-defined class objects in the initialization list is also allowed.</p>
<blockquote>
<p>When using self-defined objects, the corresponding constructors should exist.<br />
<em>const</em> and reference members can be initialized by member initialization lists only.</p>
</blockquote>
<p>Using initialization lists for setting object data members has an advantage as well. Compare the two snippets below:</p>
<pre><code>Word_Pair(const char* x, const char* y)
: word1(x), word2(y) {}</code></pre>
<pre><code>Word_Pair(const char* x, const char* y) {
    word1 = x;
    word2 = y;
}</code></pre>
<p>The first one is preferred given there is a correct type conversion constructor from char* to Word. In comparison, the second one may cause errors unless the assignment operator is overloaded.</p>
<h1 id="garbage-collection-destructors">Garbage Collection &amp; Destructors</h1>
<h3 id="memory-allocation">Memory Allocation</h3>
<p>Memory is split into 4 parts: static data, program code, stack and heap. The latter two is assigned during run-time. <strong>Stack</strong> refers to the list of local variables, temporary variables and passed arguments; <strong>heap</strong> refers to the list of objects dynamically allocated by the <em>new</em> keyword.</p>
<pre><code>void f() {
    int x=4;
    Word y(&quot;Titanic&quot;);
    int * p = new int[100];
}</code></pre>
<p>In the above example, x, y and p are all stored on the stack; and the array of integers pointed by p is put on the heap.</p>
<p>For local variables, they are constructed when defined in a block / function, and are destructed when the block / function terminates. Construction and destruction of local variables are automatically done.</p>
<p>In contrast, dynamically allocated memory will remain occupied until program terminates if nothing is done.</p>
<pre><code>main() {
    for (int j=1; j &lt;= 10000; j++) {
        int * snoopy = new int[100];
        int * vampire = new int[100];
        snoopy = vampire;
    }
}</code></pre>
<p>Here, there are no longer any reference to the first dynamically allocated integer array. It has now become <strong>garbage</strong>; this is known as <strong>memory leak</strong>. To prevent this from occurring, programmers will need to specifically remove the garbage. This is done by the <em>delete</em> command.</p>
<pre><code>main() {
    Stack * p = new Stack(9);
    int * q = new int[100];
    delete p;
    delete [] q;
    p = NULL;
    q = NULL;
}   </code></pre>
<p>However, careless use of pointers and <em>delete</em> may lead to <strong>dangling pointers</strong>. Dangling pointers arise when the memory pointed by a pointer is invalid but the user thinks the address is still valid. This is often caused by <strong>pointer aliasing</strong> - object pointed to by more than one pointer.</p>
<pre><code>main() {
    char * p;
    char * q = new char[128];
    p = q;
    delete [] q; //p is now dangling
    q = 0;
    p[0] = &#39;a&#39;; //segmentation fault</code></pre>
<p>In C++, <strong>destructors</strong> is a member function called when an object goes out of scope, and can be used to recycle garbage.</p>
<pre><code>~Word() { delete [] str; }</code></pre>
<blockquote>
<p>Destructors take no arguments and has no return type, hence there can be only one destructor in each class.<br />
A destructor that does nothing will be created automatically, if one is not supplied.</p>
</blockquote>
<h1 id="order-of-construction-and-destruction">Order of construction and destruction</h1>
<p>When an object is created, its data members are created first. The order of destruction, however, is exactly the opposite of construction; data members are deleted after the object is deleted. Using the below as an example:</p>
<pre><code>class Clock {
public:
    Clock() { cout &lt;&lt; &quot;Constructor Clock\n&quot;; }
    ~Clock() { cout &lt;&lt; &quot;Destructor Clock\n&quot;; }
};

class Postoffice {
    Clock clock;
public:
    Postoffice() { cout &lt;&lt; &quot;Constructor Postoffice\n&quot;; }
    ~Postoffice() { cout &lt;&lt; &quot;Destructor Postoffice\n&quot;; }
};  </code></pre>
<p>Declaring one <em>Postoffice</em> object in <em>main()</em> will lead to the following:</p>
<blockquote>
<p>Constructor Clock<br />
Constructor Postoffice<br />
Destructor Postoffice<br />
Destructor Clock</p>
</blockquote>
<p>Here, the constructor of data members is done in the object constructor; this will be the default constructor if it is not specified. Hence, the two snippets below are equivalent.</p>
<pre><code>Postoffice::Postoffice() {}</code></pre>
<pre><code>Postoffice::Postoffice() : Clock() {}</code></pre>
<h3 id="dynamically-allocated-memory">Dynamically allocated memory</h3>
<p>The next example illustrates the use of dynamically allocated memory;</p>
<pre><code>class Postoffice {
    Clock * clock;
public:
    Postoffice() {
        clock = new Clock;
        cout &lt;&lt; &quot;Constructor Postoffice\n&quot;;
    }
    ~Postoffice() { cout &lt;&lt; &quot;Destructor Postoffice\n&quot;; }
};  </code></pre>
<blockquote>
<p>Constructor Clock<br />
Constructor Postoffice<br />
Destructor Postoffice</p>
</blockquote>
<p>We now see that when object A owns object B, A is <strong>responsible for B's destruction</strong>. Since that is not implemented in the above code, memory leak will occur. A quick fix is shown below:</p>
<pre><code>~Postoffice() {
    delete clock;
    cout &lt;&lt; &quot;Destructor Postoffice\n&quot;;
}</code></pre>
<h3 id="multiple-objects">Multiple objects</h3>
<pre><code>class Postoffice {
    Clock clock;
    Room room;
public:
    Postoffice() { cout &lt;&lt; &quot;Constructor Postoffice\n&quot;; }
    ~Postoffice() { cout &lt;&lt; &quot;Destructor Postoffice\n&quot;; }
};</code></pre>
<p>Here, the objects are created in the order of <em>Clock</em> -&gt; <em>Room</em> -&gt; <em>Postoffice</em>, and are destructed in the order of <em>Postoffice</em> -&gt; <em>Room</em> -&gt; <em>Clock</em>.</p>
<h3 id="temporary-objects">Temporary objects</h3>
<pre><code>class Clock {
    int HHMM;
public:
    Clock() : HHMM(0) { cout &lt;&lt; &quot;Constructor Clock\n&quot;; }
    Clock(int hhmm) : HHMM(hhmm) { cout &lt;&lt; &quot;Constructor clock at &quot; &lt;&lt; HHMM &lt;&lt; endl; }
    ~Clock() { cout &lt;&lt; &quot;Destructor Clock\n&quot;; }
};

class Postoffice {
    Clock clock;
public:
    Postoffice() {
        clock = Clock(800);
        cout &lt;&lt; &quot;Constructor Postoffice\n&quot;;
    }
    ~Postoffice() { cout &lt;&lt; &quot;Destructor Postoffice\n&quot;; }
};</code></pre>
<p>In this case, clock is constructed twice, first in the data member and second by the explicit call to <em>Clock(800)</em>. The latter is a <strong>temporary object</strong> and is deleted immediately behind the scene. Hence the following output will be produced:</p>
<blockquote>
<p>Constructor Clock<br />
Constructor Clock at 800<br />
Destructor Clock<br />
Constructor Postoffice<br />
Destructor Postoffice<br />
Destructor Clock</p>
</blockquote>
</body>
</html>
